# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
  id: ID!
  name: String
  email: String
  password: PasswordState
  isAdmin: Boolean
  account: Account
}

type PasswordState {
  isSet: Boolean!
}

input UserWhereUniqueInput {
  id: ID
  name: String
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
  isAdmin: BooleanFilter
  account: AccountWhereInput
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input BooleanFilter {
  equals: Boolean
  not: BooleanFilter
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
  isAdmin: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  isAdmin: Boolean
  account: AccountRelateToOneForUpdateInput
}

input AccountRelateToOneForUpdateInput {
  create: AccountCreateInput
  connect: AccountWhereUniqueInput
  disconnect: Boolean
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  email: String
  password: String
  isAdmin: Boolean
  account: AccountRelateToOneForCreateInput
}

input AccountRelateToOneForCreateInput {
  create: AccountCreateInput
  connect: AccountWhereUniqueInput
}

type Account {
  id: ID!
  firstName: String
  lastName: String
  phone: String
  address1: String
  address2: String
  city: String
  state: State
  zip: Int
  user: User
}

input AccountWhereUniqueInput {
  id: ID
  phone: String
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  id: IDFilter
  firstName: StringFilter
  lastName: StringFilter
  phone: StringFilter
  address1: StringFilter
  address2: StringFilter
  city: StringFilter
  state: StateWhereInput
  zip: IntNullableFilter
  user: UserWhereInput
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: IntNullableFilter
}

input AccountOrderByInput {
  id: OrderDirection
  firstName: OrderDirection
  lastName: OrderDirection
  phone: OrderDirection
  address1: OrderDirection
  address2: OrderDirection
  city: OrderDirection
  zip: OrderDirection
}

input AccountUpdateInput {
  firstName: String
  lastName: String
  phone: String
  address1: String
  address2: String
  city: String
  state: StateRelateToOneForUpdateInput
  zip: Int
  user: UserRelateToOneForUpdateInput
}

input StateRelateToOneForUpdateInput {
  create: StateCreateInput
  connect: StateWhereUniqueInput
  disconnect: Boolean
}

input UserRelateToOneForUpdateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: Boolean
}

input AccountUpdateArgs {
  where: AccountWhereUniqueInput!
  data: AccountUpdateInput!
}

input AccountCreateInput {
  firstName: String
  lastName: String
  phone: String
  address1: String
  address2: String
  city: String
  state: StateRelateToOneForCreateInput
  zip: Int
  user: UserRelateToOneForCreateInput
}

input StateRelateToOneForCreateInput {
  create: StateCreateInput
  connect: StateWhereUniqueInput
}

input UserRelateToOneForCreateInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type Tag {
  id: ID!
  name: String
  locations(where: LocationWhereInput! = {}, orderBy: [LocationOrderByInput!]! = [], take: Int, skip: Int! = 0): [Location!]
  locationsCount(where: LocationWhereInput! = {}): Int
}

input TagWhereUniqueInput {
  id: ID
}

input TagWhereInput {
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
  id: IDFilter
  name: StringFilter
  locations: LocationManyRelationFilter
}

input LocationManyRelationFilter {
  every: LocationWhereInput
  some: LocationWhereInput
  none: LocationWhereInput
}

input TagOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input TagUpdateInput {
  name: String
  locations: LocationRelateToManyForUpdateInput
}

input LocationRelateToManyForUpdateInput {
  disconnect: [LocationWhereUniqueInput!]
  set: [LocationWhereUniqueInput!]
  create: [LocationCreateInput!]
  connect: [LocationWhereUniqueInput!]
}

input TagUpdateArgs {
  where: TagWhereUniqueInput!
  data: TagUpdateInput!
}

input TagCreateInput {
  name: String
  locations: LocationRelateToManyForCreateInput
}

input LocationRelateToManyForCreateInput {
  create: [LocationCreateInput!]
  connect: [LocationWhereUniqueInput!]
}

type Location {
  id: ID!
  name: String
  shortDescription: String
  state: State
  city: City
  status: String
  description: Location_description_Document
  createdDate: DateTime
  tags(where: TagWhereInput! = {}, orderBy: [TagOrderByInput!]! = [], take: Int, skip: Int! = 0): [Tag!]
  tagsCount(where: TagWhereInput! = {}): Int
  images(where: ImageWhereInput! = {}, orderBy: [ImageOrderByInput!]! = [], take: Int, skip: Int! = 0): [Image!]
  imagesCount(where: ImageWhereInput! = {}): Int
}

type Location_description_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input LocationWhereUniqueInput {
  id: ID
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
  id: IDFilter
  name: StringFilter
  shortDescription: StringFilter
  state: StateWhereInput
  city: CityWhereInput
  status: StringNullableFilter
  createdDate: DateTimeNullableFilter
  tags: TagManyRelationFilter
  images: ImageManyRelationFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input TagManyRelationFilter {
  every: TagWhereInput
  some: TagWhereInput
  none: TagWhereInput
}

input ImageManyRelationFilter {
  every: ImageWhereInput
  some: ImageWhereInput
  none: ImageWhereInput
}

input LocationOrderByInput {
  id: OrderDirection
  name: OrderDirection
  shortDescription: OrderDirection
  status: OrderDirection
  createdDate: OrderDirection
}

input LocationUpdateInput {
  name: String
  shortDescription: String
  state: StateRelateToOneForUpdateInput
  city: CityRelateToOneForUpdateInput
  status: String
  description: JSON
  createdDate: DateTime
  tags: TagRelateToManyForUpdateInput
  images: ImageRelateToManyForUpdateInput
}

input CityRelateToOneForUpdateInput {
  create: CityCreateInput
  connect: CityWhereUniqueInput
  disconnect: Boolean
}

input TagRelateToManyForUpdateInput {
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

input ImageRelateToManyForUpdateInput {
  disconnect: [ImageWhereUniqueInput!]
  set: [ImageWhereUniqueInput!]
  create: [ImageCreateInput!]
  connect: [ImageWhereUniqueInput!]
}

input LocationUpdateArgs {
  where: LocationWhereUniqueInput!
  data: LocationUpdateInput!
}

input LocationCreateInput {
  name: String
  shortDescription: String
  state: StateRelateToOneForCreateInput
  city: CityRelateToOneForCreateInput
  status: String
  description: JSON
  createdDate: DateTime
  tags: TagRelateToManyForCreateInput
  images: ImageRelateToManyForCreateInput
}

input CityRelateToOneForCreateInput {
  create: CityCreateInput
  connect: CityWhereUniqueInput
}

input TagRelateToManyForCreateInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

input ImageRelateToManyForCreateInput {
  create: [ImageCreateInput!]
  connect: [ImageWhereUniqueInput!]
}

type FipsGeo {
  id: ID!
  areaName: String
  summaryLevel: String
  state: State
  county: County
  countySubdivision: CountySubdivision
  city: City
  consolidatedCity: String
}

input FipsGeoWhereUniqueInput {
  id: ID
}

input FipsGeoWhereInput {
  AND: [FipsGeoWhereInput!]
  OR: [FipsGeoWhereInput!]
  NOT: [FipsGeoWhereInput!]
  id: IDFilter
  areaName: StringFilter
  summaryLevel: StringNullableFilter
  state: StateWhereInput
  county: CountyWhereInput
  countySubdivision: CountySubdivisionWhereInput
  city: CityWhereInput
  consolidatedCity: StringFilter
}

input FipsGeoOrderByInput {
  id: OrderDirection
  areaName: OrderDirection
  summaryLevel: OrderDirection
  consolidatedCity: OrderDirection
}

input FipsGeoUpdateInput {
  areaName: String
  summaryLevel: String
  state: StateRelateToOneForUpdateInput
  county: CountyRelateToOneForUpdateInput
  countySubdivision: CountySubdivisionRelateToOneForUpdateInput
  city: CityRelateToOneForUpdateInput
  consolidatedCity: String
}

input CountyRelateToOneForUpdateInput {
  create: CountyCreateInput
  connect: CountyWhereUniqueInput
  disconnect: Boolean
}

input CountySubdivisionRelateToOneForUpdateInput {
  create: CountySubdivisionCreateInput
  connect: CountySubdivisionWhereUniqueInput
  disconnect: Boolean
}

input FipsGeoUpdateArgs {
  where: FipsGeoWhereUniqueInput!
  data: FipsGeoUpdateInput!
}

input FipsGeoCreateInput {
  areaName: String
  summaryLevel: String
  state: StateRelateToOneForCreateInput
  county: CountyRelateToOneForCreateInput
  countySubdivision: CountySubdivisionRelateToOneForCreateInput
  city: CityRelateToOneForCreateInput
  consolidatedCity: String
}

input CountyRelateToOneForCreateInput {
  create: CountyCreateInput
  connect: CountyWhereUniqueInput
}

input CountySubdivisionRelateToOneForCreateInput {
  create: CountySubdivisionCreateInput
  connect: CountySubdivisionWhereUniqueInput
}

type State {
  id: ID!
  code: String
  fipsCode: String
  name: String
  capital: String
  largestCity: String
  population: Int
  areaSqMi: Int
  landAreaSqMi: Int
  waterAreaSqMi: Int
  locations(where: LocationWhereInput! = {}, orderBy: [LocationOrderByInput!]! = [], take: Int, skip: Int! = 0): [Location!]
  locationsCount(where: LocationWhereInput! = {}): Int
  fipsGeo(where: FipsGeoWhereInput! = {}, orderBy: [FipsGeoOrderByInput!]! = [], take: Int, skip: Int! = 0): [FipsGeo!]
  fipsGeoCount(where: FipsGeoWhereInput! = {}): Int
  county(where: CountyWhereInput! = {}, orderBy: [CountyOrderByInput!]! = [], take: Int, skip: Int! = 0): [County!]
  countyCount(where: CountyWhereInput! = {}): Int
  countySubdivision(where: CountySubdivisionWhereInput! = {}, orderBy: [CountySubdivisionOrderByInput!]! = [], take: Int, skip: Int! = 0): [CountySubdivision!]
  countySubdivisionCount(where: CountySubdivisionWhereInput! = {}): Int
  city(where: CityWhereInput! = {}, orderBy: [CityOrderByInput!]! = [], take: Int, skip: Int! = 0): [City!]
  cityCount(where: CityWhereInput! = {}): Int
}

input StateWhereUniqueInput {
  id: ID
  code: String
  fipsCode: String
  name: String
}

input StateWhereInput {
  AND: [StateWhereInput!]
  OR: [StateWhereInput!]
  NOT: [StateWhereInput!]
  id: IDFilter
  code: StringFilter
  fipsCode: StringFilter
  name: StringFilter
  capital: StringFilter
  largestCity: StringFilter
  population: IntNullableFilter
  areaSqMi: IntNullableFilter
  landAreaSqMi: IntNullableFilter
  waterAreaSqMi: IntNullableFilter
  locations: LocationManyRelationFilter
  fipsGeo: FipsGeoManyRelationFilter
  county: CountyManyRelationFilter
  countySubdivision: CountySubdivisionManyRelationFilter
  city: CityManyRelationFilter
}

input FipsGeoManyRelationFilter {
  every: FipsGeoWhereInput
  some: FipsGeoWhereInput
  none: FipsGeoWhereInput
}

input CountyManyRelationFilter {
  every: CountyWhereInput
  some: CountyWhereInput
  none: CountyWhereInput
}

input CountySubdivisionManyRelationFilter {
  every: CountySubdivisionWhereInput
  some: CountySubdivisionWhereInput
  none: CountySubdivisionWhereInput
}

input CityManyRelationFilter {
  every: CityWhereInput
  some: CityWhereInput
  none: CityWhereInput
}

input StateOrderByInput {
  id: OrderDirection
  code: OrderDirection
  fipsCode: OrderDirection
  name: OrderDirection
  capital: OrderDirection
  largestCity: OrderDirection
  population: OrderDirection
  areaSqMi: OrderDirection
  landAreaSqMi: OrderDirection
  waterAreaSqMi: OrderDirection
}

input StateUpdateInput {
  code: String
  fipsCode: String
  name: String
  capital: String
  largestCity: String
  population: Int
  areaSqMi: Int
  landAreaSqMi: Int
  waterAreaSqMi: Int
  locations: LocationRelateToManyForUpdateInput
  fipsGeo: FipsGeoRelateToManyForUpdateInput
  county: CountyRelateToManyForUpdateInput
  countySubdivision: CountySubdivisionRelateToManyForUpdateInput
  city: CityRelateToManyForUpdateInput
}

input FipsGeoRelateToManyForUpdateInput {
  disconnect: [FipsGeoWhereUniqueInput!]
  set: [FipsGeoWhereUniqueInput!]
  create: [FipsGeoCreateInput!]
  connect: [FipsGeoWhereUniqueInput!]
}

input CountyRelateToManyForUpdateInput {
  disconnect: [CountyWhereUniqueInput!]
  set: [CountyWhereUniqueInput!]
  create: [CountyCreateInput!]
  connect: [CountyWhereUniqueInput!]
}

input CountySubdivisionRelateToManyForUpdateInput {
  disconnect: [CountySubdivisionWhereUniqueInput!]
  set: [CountySubdivisionWhereUniqueInput!]
  create: [CountySubdivisionCreateInput!]
  connect: [CountySubdivisionWhereUniqueInput!]
}

input CityRelateToManyForUpdateInput {
  disconnect: [CityWhereUniqueInput!]
  set: [CityWhereUniqueInput!]
  create: [CityCreateInput!]
  connect: [CityWhereUniqueInput!]
}

input StateUpdateArgs {
  where: StateWhereUniqueInput!
  data: StateUpdateInput!
}

input StateCreateInput {
  code: String
  fipsCode: String
  name: String
  capital: String
  largestCity: String
  population: Int
  areaSqMi: Int
  landAreaSqMi: Int
  waterAreaSqMi: Int
  locations: LocationRelateToManyForCreateInput
  fipsGeo: FipsGeoRelateToManyForCreateInput
  county: CountyRelateToManyForCreateInput
  countySubdivision: CountySubdivisionRelateToManyForCreateInput
  city: CityRelateToManyForCreateInput
}

input FipsGeoRelateToManyForCreateInput {
  create: [FipsGeoCreateInput!]
  connect: [FipsGeoWhereUniqueInput!]
}

input CountyRelateToManyForCreateInput {
  create: [CountyCreateInput!]
  connect: [CountyWhereUniqueInput!]
}

input CountySubdivisionRelateToManyForCreateInput {
  create: [CountySubdivisionCreateInput!]
  connect: [CountySubdivisionWhereUniqueInput!]
}

input CityRelateToManyForCreateInput {
  create: [CityCreateInput!]
  connect: [CityWhereUniqueInput!]
}

type County {
  id: ID!
  fipsCode: String
  name: String
  type: String
  state: State
  countySubdivision(where: CountySubdivisionWhereInput! = {}, orderBy: [CountySubdivisionOrderByInput!]! = [], take: Int, skip: Int! = 0): [CountySubdivision!]
  countySubdivisionCount(where: CountySubdivisionWhereInput! = {}): Int
  fipsGeo(where: FipsGeoWhereInput! = {}, orderBy: [FipsGeoOrderByInput!]! = [], take: Int, skip: Int! = 0): [FipsGeo!]
  fipsGeoCount(where: FipsGeoWhereInput! = {}): Int
}

input CountyWhereUniqueInput {
  id: ID
  fipsCode: String
}

input CountyWhereInput {
  AND: [CountyWhereInput!]
  OR: [CountyWhereInput!]
  NOT: [CountyWhereInput!]
  id: IDFilter
  fipsCode: StringFilter
  name: StringFilter
  type: StringNullableFilter
  state: StateWhereInput
  countySubdivision: CountySubdivisionManyRelationFilter
  fipsGeo: FipsGeoManyRelationFilter
}

input CountyOrderByInput {
  id: OrderDirection
  fipsCode: OrderDirection
  name: OrderDirection
  type: OrderDirection
}

input CountyUpdateInput {
  fipsCode: String
  name: String
  type: String
  state: StateRelateToOneForUpdateInput
  countySubdivision: CountySubdivisionRelateToManyForUpdateInput
  fipsGeo: FipsGeoRelateToManyForUpdateInput
}

input CountyUpdateArgs {
  where: CountyWhereUniqueInput!
  data: CountyUpdateInput!
}

input CountyCreateInput {
  fipsCode: String
  name: String
  type: String
  state: StateRelateToOneForCreateInput
  countySubdivision: CountySubdivisionRelateToManyForCreateInput
  fipsGeo: FipsGeoRelateToManyForCreateInput
}

type CountySubdivision {
  id: ID!
  fipsCode: String
  name: String
  county: County
  state: State
  fipsGeo(where: FipsGeoWhereInput! = {}, orderBy: [FipsGeoOrderByInput!]! = [], take: Int, skip: Int! = 0): [FipsGeo!]
  fipsGeoCount(where: FipsGeoWhereInput! = {}): Int
}

input CountySubdivisionWhereUniqueInput {
  id: ID
  fipsCode: String
}

input CountySubdivisionWhereInput {
  AND: [CountySubdivisionWhereInput!]
  OR: [CountySubdivisionWhereInput!]
  NOT: [CountySubdivisionWhereInput!]
  id: IDFilter
  fipsCode: StringFilter
  name: StringFilter
  county: CountyWhereInput
  state: StateWhereInput
  fipsGeo: FipsGeoManyRelationFilter
}

input CountySubdivisionOrderByInput {
  id: OrderDirection
  fipsCode: OrderDirection
  name: OrderDirection
}

input CountySubdivisionUpdateInput {
  fipsCode: String
  name: String
  county: CountyRelateToOneForUpdateInput
  state: StateRelateToOneForUpdateInput
  fipsGeo: FipsGeoRelateToManyForUpdateInput
}

input CountySubdivisionUpdateArgs {
  where: CountySubdivisionWhereUniqueInput!
  data: CountySubdivisionUpdateInput!
}

input CountySubdivisionCreateInput {
  fipsCode: String
  name: String
  county: CountyRelateToOneForCreateInput
  state: StateRelateToOneForCreateInput
  fipsGeo: FipsGeoRelateToManyForCreateInput
}

type City {
  id: ID!
  fipsCode: String
  name: String
  cbsa: String
  necta: String
  state: State
  locations(where: LocationWhereInput! = {}, orderBy: [LocationOrderByInput!]! = [], take: Int, skip: Int! = 0): [Location!]
  locationsCount(where: LocationWhereInput! = {}): Int
  fipsGeo(where: FipsGeoWhereInput! = {}, orderBy: [FipsGeoOrderByInput!]! = [], take: Int, skip: Int! = 0): [FipsGeo!]
  fipsGeoCount(where: FipsGeoWhereInput! = {}): Int
}

input CityWhereUniqueInput {
  id: ID
  fipsCode: String
}

input CityWhereInput {
  AND: [CityWhereInput!]
  OR: [CityWhereInput!]
  NOT: [CityWhereInput!]
  id: IDFilter
  fipsCode: StringFilter
  name: StringFilter
  cbsa: StringFilter
  necta: StringFilter
  state: StateWhereInput
  locations: LocationManyRelationFilter
  fipsGeo: FipsGeoManyRelationFilter
}

input CityOrderByInput {
  id: OrderDirection
  fipsCode: OrderDirection
  name: OrderDirection
  cbsa: OrderDirection
  necta: OrderDirection
}

input CityUpdateInput {
  fipsCode: String
  name: String
  cbsa: String
  necta: String
  state: StateRelateToOneForUpdateInput
  locations: LocationRelateToManyForUpdateInput
  fipsGeo: FipsGeoRelateToManyForUpdateInput
}

input CityUpdateArgs {
  where: CityWhereUniqueInput!
  data: CityUpdateInput!
}

input CityCreateInput {
  fipsCode: String
  name: String
  cbsa: String
  necta: String
  state: StateRelateToOneForCreateInput
  locations: LocationRelateToManyForCreateInput
  fipsGeo: FipsGeoRelateToManyForCreateInput
}

type Image {
  id: ID!
  filename: String
  locations(where: LocationWhereInput! = {}, orderBy: [LocationOrderByInput!]! = [], take: Int, skip: Int! = 0): [Location!]
  locationsCount(where: LocationWhereInput! = {}): Int
}

input ImageWhereUniqueInput {
  id: ID
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
  id: IDFilter
  filename: StringFilter
  locations: LocationManyRelationFilter
}

input ImageOrderByInput {
  id: OrderDirection
  filename: OrderDirection
}

input ImageUpdateInput {
  filename: String
  locations: LocationRelateToManyForUpdateInput
}

input ImageUpdateArgs {
  where: ImageWhereUniqueInput!
  data: ImageUpdateInput!
}

input ImageCreateInput {
  filename: String
  locations: LocationRelateToManyForCreateInput
}

type ContentBlock {
  id: ID!
  active: Boolean
  page: String
  column: Int
  blockOrder: Int
  richText: ContentBlock_richText_Document
}

type ContentBlock_richText_Document {
  document(hydrateRelationships: Boolean! = false): JSON!
}

input ContentBlockWhereUniqueInput {
  id: ID
}

input ContentBlockWhereInput {
  AND: [ContentBlockWhereInput!]
  OR: [ContentBlockWhereInput!]
  NOT: [ContentBlockWhereInput!]
  id: IDFilter
  active: BooleanFilter
  page: StringFilter
  column: IntNullableFilter
  blockOrder: IntNullableFilter
}

input ContentBlockOrderByInput {
  id: OrderDirection
  active: OrderDirection
  page: OrderDirection
  column: OrderDirection
  blockOrder: OrderDirection
}

input ContentBlockUpdateInput {
  active: Boolean
  page: String
  column: Int
  blockOrder: Int
  richText: JSON
}

input ContentBlockUpdateArgs {
  where: ContentBlockWhereUniqueInput!
  data: ContentBlockUpdateInput!
}

input ContentBlockCreateInput {
  active: Boolean
  page: String
  column: Int
  blockOrder: Int
  richText: JSON
}

type Page {
  id: ID!
  active: Boolean
  name: String
  title: String
  subTitle: String
}

input PageWhereUniqueInput {
  id: ID
}

input PageWhereInput {
  AND: [PageWhereInput!]
  OR: [PageWhereInput!]
  NOT: [PageWhereInput!]
  id: IDFilter
  active: BooleanFilter
  name: StringFilter
  title: StringFilter
  subTitle: StringFilter
}

input PageOrderByInput {
  id: OrderDirection
  active: OrderDirection
  name: OrderDirection
  title: OrderDirection
  subTitle: OrderDirection
}

input PageUpdateInput {
  active: Boolean
  name: String
  title: String
  subTitle: String
}

input PageUpdateArgs {
  where: PageWhereUniqueInput!
  data: PageUpdateInput!
}

input PageCreateInput {
  active: Boolean
  name: String
  title: String
  subTitle: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createAccount(data: AccountCreateInput!): Account
  createAccounts(data: [AccountCreateInput!]!): [Account]
  updateAccount(where: AccountWhereUniqueInput!, data: AccountUpdateInput!): Account
  updateAccounts(data: [AccountUpdateArgs!]!): [Account]
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteAccounts(where: [AccountWhereUniqueInput!]!): [Account]
  createTag(data: TagCreateInput!): Tag
  createTags(data: [TagCreateInput!]!): [Tag]
  updateTag(where: TagWhereUniqueInput!, data: TagUpdateInput!): Tag
  updateTags(data: [TagUpdateArgs!]!): [Tag]
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteTags(where: [TagWhereUniqueInput!]!): [Tag]
  createLocation(data: LocationCreateInput!): Location
  createLocations(data: [LocationCreateInput!]!): [Location]
  updateLocation(where: LocationWhereUniqueInput!, data: LocationUpdateInput!): Location
  updateLocations(data: [LocationUpdateArgs!]!): [Location]
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteLocations(where: [LocationWhereUniqueInput!]!): [Location]
  createFipsGeo(data: FipsGeoCreateInput!): FipsGeo
  createFipsGeos(data: [FipsGeoCreateInput!]!): [FipsGeo]
  updateFipsGeo(where: FipsGeoWhereUniqueInput!, data: FipsGeoUpdateInput!): FipsGeo
  updateFipsGeos(data: [FipsGeoUpdateArgs!]!): [FipsGeo]
  deleteFipsGeo(where: FipsGeoWhereUniqueInput!): FipsGeo
  deleteFipsGeos(where: [FipsGeoWhereUniqueInput!]!): [FipsGeo]
  createState(data: StateCreateInput!): State
  createStates(data: [StateCreateInput!]!): [State]
  updateState(where: StateWhereUniqueInput!, data: StateUpdateInput!): State
  updateStates(data: [StateUpdateArgs!]!): [State]
  deleteState(where: StateWhereUniqueInput!): State
  deleteStates(where: [StateWhereUniqueInput!]!): [State]
  createCounty(data: CountyCreateInput!): County
  createCounties(data: [CountyCreateInput!]!): [County]
  updateCounty(where: CountyWhereUniqueInput!, data: CountyUpdateInput!): County
  updateCounties(data: [CountyUpdateArgs!]!): [County]
  deleteCounty(where: CountyWhereUniqueInput!): County
  deleteCounties(where: [CountyWhereUniqueInput!]!): [County]
  createCountySubdivision(data: CountySubdivisionCreateInput!): CountySubdivision
  createCountySubdivisions(data: [CountySubdivisionCreateInput!]!): [CountySubdivision]
  updateCountySubdivision(where: CountySubdivisionWhereUniqueInput!, data: CountySubdivisionUpdateInput!): CountySubdivision
  updateCountySubdivisions(data: [CountySubdivisionUpdateArgs!]!): [CountySubdivision]
  deleteCountySubdivision(where: CountySubdivisionWhereUniqueInput!): CountySubdivision
  deleteCountySubdivisions(where: [CountySubdivisionWhereUniqueInput!]!): [CountySubdivision]
  createCity(data: CityCreateInput!): City
  createCities(data: [CityCreateInput!]!): [City]
  updateCity(where: CityWhereUniqueInput!, data: CityUpdateInput!): City
  updateCities(data: [CityUpdateArgs!]!): [City]
  deleteCity(where: CityWhereUniqueInput!): City
  deleteCities(where: [CityWhereUniqueInput!]!): [City]
  createImage(data: ImageCreateInput!): Image
  createImages(data: [ImageCreateInput!]!): [Image]
  updateImage(where: ImageWhereUniqueInput!, data: ImageUpdateInput!): Image
  updateImages(data: [ImageUpdateArgs!]!): [Image]
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteImages(where: [ImageWhereUniqueInput!]!): [Image]
  createContentBlock(data: ContentBlockCreateInput!): ContentBlock
  createContentBlocks(data: [ContentBlockCreateInput!]!): [ContentBlock]
  updateContentBlock(where: ContentBlockWhereUniqueInput!, data: ContentBlockUpdateInput!): ContentBlock
  updateContentBlocks(data: [ContentBlockUpdateArgs!]!): [ContentBlock]
  deleteContentBlock(where: ContentBlockWhereUniqueInput!): ContentBlock
  deleteContentBlocks(where: [ContentBlockWhereUniqueInput!]!): [ContentBlock]
  createPage(data: PageCreateInput!): Page
  createPages(data: [PageCreateInput!]!): [Page]
  updatePage(where: PageWhereUniqueInput!, data: PageUpdateInput!): Page
  updatePages(data: [PageUpdateArgs!]!): [Page]
  deletePage(where: PageWhereUniqueInput!): Page
  deletePages(where: [PageWhereUniqueInput!]!): [Page]
  endSession: Boolean!
  authenticateUserWithPassword(email: String!, password: String!): UserAuthenticationWithPasswordResult
  createInitialUser(data: CreateInitialUserInput!): UserAuthenticationWithPasswordSuccess!
}

union UserAuthenticationWithPasswordResult = UserAuthenticationWithPasswordSuccess | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String
  email: String
  password: String
}

type Query {
  users(where: UserWhereInput! = {}, orderBy: [UserOrderByInput!]! = [], take: Int, skip: Int! = 0): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  accounts(where: AccountWhereInput! = {}, orderBy: [AccountOrderByInput!]! = [], take: Int, skip: Int! = 0): [Account!]
  account(where: AccountWhereUniqueInput!): Account
  accountsCount(where: AccountWhereInput! = {}): Int
  tags(where: TagWhereInput! = {}, orderBy: [TagOrderByInput!]! = [], take: Int, skip: Int! = 0): [Tag!]
  tag(where: TagWhereUniqueInput!): Tag
  tagsCount(where: TagWhereInput! = {}): Int
  locations(where: LocationWhereInput! = {}, orderBy: [LocationOrderByInput!]! = [], take: Int, skip: Int! = 0): [Location!]
  location(where: LocationWhereUniqueInput!): Location
  locationsCount(where: LocationWhereInput! = {}): Int
  fipsGeos(where: FipsGeoWhereInput! = {}, orderBy: [FipsGeoOrderByInput!]! = [], take: Int, skip: Int! = 0): [FipsGeo!]
  fipsGeo(where: FipsGeoWhereUniqueInput!): FipsGeo
  fipsGeosCount(where: FipsGeoWhereInput! = {}): Int
  states(where: StateWhereInput! = {}, orderBy: [StateOrderByInput!]! = [], take: Int, skip: Int! = 0): [State!]
  state(where: StateWhereUniqueInput!): State
  statesCount(where: StateWhereInput! = {}): Int
  counties(where: CountyWhereInput! = {}, orderBy: [CountyOrderByInput!]! = [], take: Int, skip: Int! = 0): [County!]
  county(where: CountyWhereUniqueInput!): County
  countiesCount(where: CountyWhereInput! = {}): Int
  countySubdivisions(where: CountySubdivisionWhereInput! = {}, orderBy: [CountySubdivisionOrderByInput!]! = [], take: Int, skip: Int! = 0): [CountySubdivision!]
  countySubdivision(where: CountySubdivisionWhereUniqueInput!): CountySubdivision
  countySubdivisionsCount(where: CountySubdivisionWhereInput! = {}): Int
  cities(where: CityWhereInput! = {}, orderBy: [CityOrderByInput!]! = [], take: Int, skip: Int! = 0): [City!]
  city(where: CityWhereUniqueInput!): City
  citiesCount(where: CityWhereInput! = {}): Int
  images(where: ImageWhereInput! = {}, orderBy: [ImageOrderByInput!]! = [], take: Int, skip: Int! = 0): [Image!]
  image(where: ImageWhereUniqueInput!): Image
  imagesCount(where: ImageWhereInput! = {}): Int
  contentBlocks(where: ContentBlockWhereInput! = {}, orderBy: [ContentBlockOrderByInput!]! = [], take: Int, skip: Int! = 0): [ContentBlock!]
  contentBlock(where: ContentBlockWhereUniqueInput!): ContentBlock
  contentBlocksCount(where: ContentBlockWhereInput! = {}): Int
  pages(where: PageWhereInput! = {}, orderBy: [PageOrderByInput!]! = [], take: Int, skip: Int! = 0): [Page!]
  page(where: PageWhereUniqueInput!): Page
  pagesCount(where: PageWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
  isSingleton: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  description: String
  isOrderable: Boolean!
  isFilterable: Boolean!
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

type KeystoneAdminUIFieldGroupMeta {
  label: String!
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
